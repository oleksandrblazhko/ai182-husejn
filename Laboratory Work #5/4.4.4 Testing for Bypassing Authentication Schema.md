# Тестування на обхід схеми автентифікації

|ID          |
|------------|
|WSTG-ATHN-04|

# Резюме

У комп’ютерній безпеці автентифікація — це процес спроби перевірити цифрову ідентичність відправника повідомлення. Типовим прикладом такого процесу є процес входу в систему. Тестування схеми автентифікації означає розуміння того, як працює процес автентифікації, і використання цієї інформації для обходу механізму автентифікації.

Хоча більшість програм вимагає автентифікації для отримання доступу до приватної інформації або для виконання завдань, не кожен метод автентифікації може забезпечити належний захист. Недбалість, незнання або просто недооцінка загроз безпеці часто призводять до схем автентифікації, які можна обійти, просто пропустивши сторінку входу та безпосередньо викликавши внутрішню сторінку, доступ до якої має здійснюватися лише після виконання автентифікації.

Крім того, часто можна обійти заходи автентифікації, підробивши запити та обманом змусивши програму подумати, що користувач уже автентифікований. Це можна зробити, змінивши наданий параметр URL-адреси, маніпулюючи формою або підробивши сесії.

Проблеми, пов’язані зі схемою автентифікації, можна знайти на різних етапах життєвого циклу розробки програмного забезпечення (SDLC), наприклад на етапах проектування, розробки та розгортання:

- Помилки на етапі проектування можуть включати неправильне визначення розділів програми, які потрібно захистити, вибір не застосовувати надійні протоколи шифрування для забезпечення передачі облікових даних і багато іншого.

- Помилки на етапі розробки можуть включати неправильну реалізацію функції перевірки введення або недотримання найкращих практик безпеки для певної мови.

- На етапі розгортання програми можуть виникнути проблеми під час налаштування програми (встановлення та налаштування) через відсутність необхідних технічних навичок або відсутність належної документації.

# Цілі тесту

- Переконайтеся, що автентифікація застосована для всіх служб, які її потребують.

# Як тестувати

Існує кілька методів обходу схеми автентифікації, яка використовується веб-програмою:

- Прямий запит сторінки (примусовий перегляд)
- Модифікація параметрів
- Прогноз ідентифікатора сеансу
- SQL ін'єкція

### Прямий запит на сторінку

Якщо веб-програма реалізує контроль доступу лише на сторінці входу, схему автентифікації можна обійти. Наприклад, якщо користувач безпосередньо запитує іншу сторінку за допомогою примусового перегляду, ця сторінка може не перевіряти облікові дані користувача перед наданням доступу. Спробуйте отримати прямий доступ до захищеної сторінки через адресний рядок у вашому браузері, щоб перевірити цей метод.

![directreq](https://user-images.githubusercontent.com/93474882/205521448-fafbcc30-d26b-4987-a997-a759fd81d7a0.jpg)

*Рисунок 4.4.4-1: Прямий запит до захищеної сторінки*

### Модифікація параметрів

Інша проблема, пов’язана з дизайном автентифікації, полягає в тому, що програма перевіряє успішний вхід на основі параметрів із фіксованим значенням. Користувач може змінити ці параметри, щоб отримати доступ до захищених зон без надання дійсних облікових даних. У наведеному нижче прикладі параметр «автентифікований» змінено на значення «так», що дозволяє користувачеві отримати доступ. У цьому прикладі параметр міститься в URL-адресі, але проксі також можна використовувати для зміни параметра, особливо коли параметри надсилаються як елементи форми в запиті POST або коли параметри зберігаються у файлі cookie.

```html
http://www.site.com/page.asp?authenticated=no

raven@blackbox /home $nc www.site.com 80
GET /page.asp?authenticated=yes HTTP/1.0

HTTP/1.1 200 OK
Date: Sun, 5 Dec 2022 10:22:44 GMT
Server: Apache
Connection: close
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML><HEAD>
</HEAD><BODY>
<H1>You Are Authenticated</H1>
</BODY></HTML>
```

![parammod](https://user-images.githubusercontent.com/93474882/205521432-aeed2473-1202-418e-a7c8-c0f06b8abdec.jpg)


*Рисунок 4.4.4-2: Запит на змінення параметрів*

### Прогноз ідентифікатора сеансу

Багато веб-додатків керують автентифікацією за допомогою ідентифікаторів сеансів (ідентифікаторів сеансів). Таким чином, якщо створення ідентифікатора сеансу є передбачуваним, зловмисник може знайти дійсний ідентифікатор сеансу та отримати неавторизований доступ до програми, видаючи себе за попередньо автентифікованого користувача.

На наступному малюнку значення всередині файлів cookie зростають лінійно, тому зловмиснику може бути легко вгадати дійсний ідентифікатор сеансу.

![sessid](https://user-images.githubusercontent.com/93474882/205521409-a360da26-4125-49ca-a44f-32998316be98.jpg)

*Малюнок 4.4.4-3: Значення файлів cookie за часом*

На наступному малюнку значення в файлах cookie змінюються лише частково, тому можна обмежити атаку грубою силою визначеними полями, показаними нижче.

![sessid2](https://user-images.githubusercontent.com/93474882/205521395-d135f74a-175b-4c62-84d9-745605370448.jpg)

*Рисунок 4.4.4-4: Частково змінені значення файлів cookie*

### SQL Injection (HTML Form Authentication)

SQL Injection – широко відома техніка атаки. Цей розділ не описуватиме цю техніку детально, оскільки в цьому посібнику є кілька розділів, які пояснюють техніку ін’єкцій, що виходить за рамки цього розділу.

![sqlinj](https://user-images.githubusercontent.com/93474882/205521560-a7746072-53bf-4693-b85b-28cb5d648ced.jpg)

*Рисунок 4.4.4-5: Впровадження SQL*

На наступному малюнку показано, що за допомогою простої SQL-атаки іноді можна обійти форму автентифікації.

![sqlinj2](https://user-images.githubusercontent.com/93474882/205521603-b82eb6c7-c05d-4983-bd3d-0d6a25b1a388.gif)

*Рисунок 4.4.4-6: Атака простого впровадження SQL*

### Вільне порівняння PHP

Якщо зловмиснику вдалося отримати вихідний код програми, використовуючи раніше виявлену вразливість (наприклад, обхід каталогу) або з веб-сховища (програми з відкритим вихідним кодом), можна було б виконати вдосконалені атаки проти реалізації автентифікації. процес.

У наступному прикладі (PHPBB 2.0.12 – уразливість обходу автентифікації) у рядку 2 функція unserialize() аналізує файл cookie, наданий користувачем, і встановлює значення в масиві $sessiondata. У рядку 7 хеш пароля користувача MD5, який зберігається у внутрішній базі даних ($auto_login_key), порівнюється з тим, який надає користувач ($sessiondata['autologinid']).

```php
1. if (isset($HTTP_COOKIE_VARS[$cookiename . '_sid'])) {
2.     $sessiondata = isset($HTTP_COOKIE_VARS[$cookiename . '_data']) ? unserialize(stripslashes($HTTP_COOKIE_VARS[$cookiename . '_data'])) : array();
3.     $sessionmethod = SESSION_METHOD_COOKIE;
4. }
5. $auto_login_key = $userdata['user_password'];
6. // We have to login automagically
7. if( $sessiondata['autologinid'] == $auto_login_key )
8. {
9.     // autologinid matches password
10.     $login = 1;
11.     $enable_autologin = 1;
12. }
```
У PHP порівняння між рядковим значенням і a `true` boolean value is always `true` (because the string contains a value), so by supplying the following string to the `unserialize()` function, it is possible to bypass the authentication control and log in as administrator, whose `userid` is 2:

```php
a:2:{s:11:"autologinid";b:1;s:6:"userid";s:1:"2";}  // original value: a:2:{s:11:"autologinid";s:32:"8b8e9715d12e4ca12c4c3eb4865aaf6a";s:6:"userid";s:4:"1337";}
```
Давайте розберемо, що ми зробили в цьому рядку:

1. `autologinid` тепер логічне значення `true`: це можна побачити, замінивши значення MD5 хешу пароля (`s:32:"8b8e9715d12e4ca12c4c3eb4865aaf6a"`) з `b:1`
2. `userid` is now set to the admin id: this can be seen in the last piece of the string, where we replaced our regular user ID (`s:4:"1337"`) з `s:1:"2"`

## Інструменти

- [WebGoat](https://owasp.org/www-project-webgoat/)
- [OWASP Zed Attack Proxy (ZAP)](https://www.zaproxy.org)

## Посилання

- [Нільс Теусінк: обхід автентифікації phpBB 2.0.12](http://blog.teusink.net/2008/12/classic-bug-phpbb-2012-authentication.html)
- [Девід Ендлер: «Ідентифікатор сеансу використання грубої сили та прогнозування»](https://www.cgisecurity.com/lib/SessionIDs.pdf)










